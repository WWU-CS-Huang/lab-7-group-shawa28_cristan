/*
 * This source file was generated by the Gradle 'init' task
 */
import java.util.HashMap;
import java.io.File;
import java.util.Scanner;
import java.util.Arrays;
import java.io.FileNotFoundException;
import java.util.Map;
import java.util.PriorityQueue;

class Node {
	Character character;
    Integer freq;
	Node left;
    Node right;

    Node(Integer givenFreq, Character givenCharacter){
        character = givenCharacter;
        freq = givenFreq;
        left = null;
        right = null;
    }
}

public class Huffman {

    public static HashMap<Character, Integer> freq = new HashMap<Character, Integer>();
    public static PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> {
		    if (a.freq < b.freq) return -1;
		    return 1;
		});
    public static HashMap<Character, String> encodedMap = new HashMap<Character, String>();

    public static void main(String[] args) {
            String fileName = args[0];
            File file = new File(fileName);
            StringBuilder sb = new StringBuilder();

        try {
            Scanner scanner = new Scanner(file);
            while (scanner.hasNext()) {
                sb.append(scanner.next()).append(" ");
            }
        } catch (FileNotFoundException e) {
            return;
        }
            count(sb.toString());

            for (Map.Entry<Character, Integer> en : freq.entrySet()) {
                Character key = en.getKey();
                Integer val = en.getValue();
                Node newNode = new Node(val, key);
                pq.add(newNode);
                // System.out.printf("Key: %c, Val: %d\n", key, val);
            }

        while (pq.size() > 1) {
            Node left = pq.poll();
            Node right = pq.poll();
            Node parent = new Node((left.freq + right.freq), null);

            parent.left = left;
            parent.right = right;
            pq.add(parent);
        }

	    Node tree = pq.poll();
        encodeMap(tree, "");

        // for (Map.Entry<Character, String> en : encodedMap.entrySet()) {
        //     Character key = en.getKey();
        //     String val = en.getValue();
        //     System.out.printf("Char: %c, Encoding: %s\n", key, val);
        // }

	Node tree = pq.poll();
	String encoded = encodeString(sb.toString());
	String decoded = decode(encoded);

	if (file.length() < 100) {
		System.out.println("Input string: " + file);
		System.out.println("Encoded string: " + encoded);
		System.out.println("Decoded string: " + decoded);
	}

	System.out.println("Decoded equals input: " + (decoded.equals(file)));
	System.out.println("Compression ratio: " + ((String.valueOf(encoded).length()) / (file.length() * 8)))
    }

    

    public static void count(String word) {
        for (int i = 0; i < word.length(); i++) {
            char character = word.charAt(i);
            if (freq.containsKey(character)) {
                freq.put(character, freq.get(character) + 1);
            } else {
                freq.put(character, 1);
            }
        }
    }

    public static String decode(int intPath) {
	String path = intPath.toString();
	int pathLength = path.length();
	String result = "";
	Node treePath = tree;

	for (int i = 0; i < pathLength; i++) {
		if (path.charAt(i) == 0) {
			treePath = treePath.left;
		} else {
			treePath = treePath.right;
		}
		if (treePath.value != null) {
			result += treePath.value;
		}
	}
	return result;
    }

    static void encodeMap(Node root, String curr) {
        if (root == null) {
            return;
        }
        if (root.left == null && root.right == null) {
            encodedMap.put(root.character, curr);
            return;
        }
        encodeMap(root.right, curr + '1');
        encodeMap(root.left, curr + '0');
    }

    static String encodeString(String word) {
        StringBuilder end = new StringBuilder();
        for (int i = 0; i < word.length(); i++) {
            if (encodedMap.get(word.charAt(i)) != null) {
                end.append(encodedMap.get(word.charAt(i)));
            }   
        }
        return end.toString();
    }
}
